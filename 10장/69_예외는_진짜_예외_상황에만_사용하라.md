# item 69. 예외는 진짜 예외 상황에만 사용하라.md

## 잘못된 예외 사용

다음은 예외를 잘못 사용한 경우이다.
```java
try {
    int i = 0;
    while(true)
        range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```
이러한 코드의 가장 큰 문제는 우선 `무엇을 나타내는 코드인지 알 수 없다`는 것이다.	
만약 다음과 같이 일반적인 관용구로 작성한 코드는 훨씬 명확하다.
```java
for(Mountain m : range) {
    m.climb();
}
```

첫번째와 같은 예외 코드를 작성한 이유는 성능을 높이기 위해서이다.

jvm은 배열에 접근할 때 인덱스를 초과하는지 확인하는데, 반복문도 이와 같은 동작을 수행한다.

따라서 중복을 없애기 위해 예외를 사용한 것이다.

하지만 이는 다음의 세가지 이유로 `잘못된 추론`이다.

1. 예외는 예외 상황에서 쓰이기 위해 만들어 졌기 때문에, jvm설계자가 **성능적 측면을 고려하지 않았다**.

2. try-catch 블럭 안에서는 jvm이 수행하는 **최적화가 제한**된다.

3. 앞서 본 예제에서의 중복 검사는 **실제로 중복으로 수행되지 않는다.** jvm이 최적화를 통해 없애기 때문이다.

뿐만아니라 이 메서드는 `제대로 동작하지 않을 위험`이 있다.

만약 첫번째 예시에서 의도치 않은 곳에서 ArrayIndexOutOfBoundsException이 발생할 경우

프로그램은 종료되지 않고 계속 수행될 것이고, 이는 다른 곳에 영향을 주어 잘못 동작할 수 있다.

## 교훈

예외를 예외 상황에서만 사용해야 한다. 예외를 제어 흐름에 사용하는 것은

1. 코드가 무엇을 하는지 알기 힘들고
2. 성능에도 큰 도움이 되지 않으며
3. 의도치 않은 오작동을 야기한다.

이를 더 일반화하자면 `표준적이고 쉽게 이해되는 관용구를 사용하고, 어줍잖은 기법들을 자제해야 한다`

## API 설계시의 예외

잘 설계된 API는 `클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다`

특히 **특정 상태**에서만 호출할 수 있는 메서드는 **상태 검사 메서드**를 함께 제공해야 한다.


```
Iterator 

특정 상태에서만 호출할 수 있는 메서드 : next()

상태 검사 메서드 : hasNext()
```

Iterator API는 이처럼 hasNext를 함께 제공함으로써, **클라이언트가 직접 예외를 사용하지 않아도 되도록 설계**하였다.

이러한 상태 검사 메서드를 **직접 제공하지 않는 경우에는 Optional 혹은 null과 같은 특수한 값을 반환**하도록 해야 한다.
